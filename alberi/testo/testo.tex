% Template per generare 

\documentclass[a4paper,11pt]{article}
\usepackage{lmodern}
\renewcommand*\familydefault{\sfdefault}
\usepackage{sfmath}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
		\node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
\usepackage{enumitem}
% \usepackage[group-separator={\,}]{siunitx}
\usepackage[left=2cm, right=2cm, bottom=3cm]{geometry}
\frenchspacing

\newcommand{\num}[1]{#1}

% Macro varie...
\newcommand{\file}[1]{\texttt{#1}}
\renewcommand{\arraystretch}{1.3}
\newcommand{\esempio}[2]{
\noindent\begin{minipage}{\textwidth}
\begin{tabular}{|p{11cm}|p{5cm}|}
	\hline
	\textbf{File \file{input.txt}} & \textbf{File \file{output.txt}}\\
	\hline
	\tt \small #1 &
	\tt \small #2 \\
	\hline
\end{tabular}
\end{minipage}
}

% Dati del task
\newcommand{\gara}{OII 2003}
\newcommand{\nome}{Alberi}
\newcommand{\nomebreve}{alberi}

\begin{document}
% Intestazione
\noindent{\Large \gara}
\vspace{0.5cm}

\noindent{\Huge \textbf \nome~(\texttt{\nomebreve})}

% Descrizione del task
\section*{Descrizione del problema}

Ogni albero ha un nodo spciale, detto radice, che è l'unico a non avere un padre. Un nodo si dice invece foglia se non ha alcun figlio (il padre è sempre uno solo ma i figli possono in genere essere molti).
Questo esercizio considera gli alberi binari ed ordinati.
Albero binario significa che tutti i nodi che non sono foglie hanno esattamente due figli. Albero ordinato significa che si distingue tra primo e secondo figlio, non possono venire scambiati.
Un albero con $N$ nodi av\`a i nodi etichettati con i numeri naturali da $1$ a $N$, dove nodi diversi hanno etichette diverse.

Esistono tre modi standard di metter in un qualche ordine i nodi di un albero, chiamati visita anticipata, simmetrica e posticipata.

La versione ricorsiva (in pseudocodice) delle tre visite è la seguente:

\begin{verbatim}
void anticipata(T: albero);
begin
    if (T e' vuoto) return;
    stampa(etichetta di T);
    anticipata(sottoalbero sx di T);
    anticipata(sottoalbero dx di T);
end;

void simmetrica(T: albero);
begin
    if (T e' vuoto) return;
    simmetrica(sottoalbero sx di T);
    stampa(etichetta di T);
    simmetrica(sottoalbero dx di T);
end;

void posticipata(T: albero);
begin
    if (T e' vuoto) return;
    posticipata(sottoalbero sx di T);
    posticipata(sottoalbero dx di T);
    stampa(etichetta di T);
end;
\end{verbatim}


Il problema che dovete risolvere è il seguente: dati gli ordinamenti prodotti dalla visite anticipata e posticipata, trovare quello prodotto dalla visita simmetrica.


% Implementazione
\section*{Dettagli di implementazione}
Dovrai sottoporre un file con estensione \texttt{.c} o
\texttt{.cpp}. Questo file deve implementare (in C o c++, rispettivamente)
la funzione \texttt{visita} come da seguente prototipo.

\begin{verbatim}
void visita(int N, int *PRE, int *POST, int *SIMM )
\end{verbatim}

Il parametro \texttt{N} è il numero di nodi dell'albero.

Gli array \texttt{PRE} e \texttt{POST} contengono le permutazioni dei nodi prodotte dalla visita in preordine e postordine,
l'array \texttt{SIMM} \`e da riempire con la permutazione generata invece dalla visita simmetrica.

\subsection*{Funzionamento del grader di esempio}
Nella directory relativa a questo problema è presente una versione
semplificata del grader usato durante la correzione, che potete usare
per testare le vostre soluzioni in locale. Il grader di esempio legge
i dati di input dal file \file{input.txt}, a quel punto chiama la
funzione \texttt{visita} che dovete implementare, e scrive il risultato
restituito dalla vostra funzione sul file \file{output.txt}.

Nel caso vogliate generare un input, il file \file{input.txt} deve
avere questo formato:
\begin{itemize}[noitemsep]
\item Prima riga: il numero di nodi $N$.
\item Seconda riga: $N$ interi rappresentanti la visita in preordine dell'albero .
\item Terza riga: $N$ interi rappresentanti la visita in postordine dell'albero .
\end{itemize}


% Assunzioni
\section*{Assunzioni}
\begin{itemize}[nolistsep, noitemsep]
\item $1 \le N \le 1\,000\,000 $.
\end{itemize}

% Subtasks
\section*{Subtask}
\begin{itemize}
\item \textbf{Subtask 1 [30 punti]:} $N \le 1\,000$.
\item \textbf{Subtask 2 [30 punti]:} $N \le 10\,000$.
\item \textbf{Subtask 3 [30 punti]:} $N \le 100\,000$.
\item \textbf{Subtask 4 [10 punti]:} nessuna limitazione specifica.
\end{itemize}


% Esempi
\section*{Esempio di input/output}
\esempio{
7

5 3 2 1 6 7 4

2 6 7 1 3 4 5

}{
2 3 6 1 7 5 4
}

\end{document}
